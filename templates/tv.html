<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PartyBox TV</title>
  <style>
    html, body { margin:0; padding:0; background:#000; height:100%; overflow:hidden; }
    #wrap { position:relative; width:100%; height:100%; }
    #vid { width:100%; height:100%; object-fit:contain; background:#000; }
    #msg {
      position:absolute; left:0; right:0; top:0;
      padding:16px 20px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:#fff;
      background: linear-gradient(rgba(0,0,0,0.65), rgba(0,0,0,0));
      font-size: 18px;
    }
    #note {
      position:absolute; left:0; right:0; bottom:0;
      padding:18px 22px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:#fff;
      background: linear-gradient(rgba(0,0,0,0), rgba(0,0,0,0.65));
      font-size: 22px;
      display:none;
      text-shadow: 0 2px 10px rgba(0,0,0,0.9);
    }
  </style>
</head>
<body>
<div id="wrap">
  <video id="vid" playsinline autoplay muted="false"></video>
  <div id="msg">PartyBox TV — waiting…</div>
  <div id="note"></div>
</div>

<script>
const vid = document.getElementById("vid");
const msg = document.getElementById("msg");
const note = document.getElementById("note");

let currentKey = null;

function isLocalToken(yid) {
  return (yid || "").startsWith("file:");
}
function localFilenameFromToken(yid) {
  return (yid || "").slice("file:".length).trim();
}

async function api(path, opts={}) {
  const r = await fetch(path, Object.assign({cache:"no-store"}, opts));
  if (!r.ok) throw new Error(`${path} -> ${r.status}`);
  return await r.json();
}

async function poll() {
  try {
    const state = await api("/api/state");
    if (!state.next) {
      msg.textContent = "PartyBox TV — no videos available";
      note.style.display = "none";
      return;
    }

    const n = state.next;
    const key = `${state.mode}:${n.queue_id || "idle"}:${n.youtube_id}`;

    // Update banner
    msg.textContent = (state.mode === "queue")
      ? `Up next: ${n.title}`
      : `Idle: ${n.title}`;

    // Overlay note
    if (n.note_text && n.note_text.trim()) {
      note.textContent = n.note_text.trim();
      note.style.display = "block";
    } else {
      note.style.display = "none";
    }

    // If already playing this, do nothing
    if (currentKey === key && !vid.paused) return;

    // Switch source
    currentKey = key;

    if (isLocalToken(n.youtube_id)) {
      const fn = localFilenameFromToken(n.youtube_id);
      const src = `/media/${encodeURIComponent(fn)}`;
      vid.src = src;
      vid.load();

      // Try to play with sound; if browser blocks, it will fail.
      vid.muted = false;
      const p = vid.play();
      if (p) p.catch(() => {
        // fallback to muted autoplay if required
        vid.muted = true;
        vid.play().catch(()=>{});
      });

      // Mark queue playing once we start (best effort)
      if (state.mode === "queue" && n.queue_id) {
        fetch("/api/tv/mark_playing", {
          method:"POST",
          headers:{ "Content-Type":"application/json" },
          body: JSON.stringify({queue_id: n.queue_id})
        }).catch(()=>{});
      }
    } else {
      // Legacy: YouTube embed mode not supported reliably; show message
      msg.textContent = `Cannot play YouTube embeds reliably. Use local files. (${n.youtube_id})`;
      vid.removeAttribute("src");
      vid.load();
    }
  } catch (e) {
    msg.textContent = `TV error: ${e}`;
  }
}

vid.addEventListener("ended", async () => {
  try {
    const state = await api("/api/state");
    if (state.mode === "queue" && state.next && state.next.queue_id) {
      await fetch("/api/tv/mark_done", {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({queue_id: state.next.queue_id})
      });
    }
  } catch (_) {}
});

setInterval(poll, 1000);
poll();
</script>
</body>
</html>
