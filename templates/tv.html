<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TV — PartyBox</title>
  <link rel="icon" href="/static/favicon.webp" type="image/webp" />
  <link rel="apple-touch-icon" href="/static/partybox_logo.webp" />
  <link rel="stylesheet" href="/static/style.css" />
</head>

<body class="tvPage">
  <div class="tv">
    <video class="tvBgVideo" autoplay muted loop playsinline preload="auto" aria-hidden="true">
      <source src="/static/partybox_animated_background.mp4" type="video/mp4" />
    </video>
    <img class="tvCenterLogo" src="/static/partybox_t.png" alt="PartyBox" />
    <img id="tv_mode_logo" class="tvModeLogo" src="/static/partybox_t.png" alt="PartyBox" />
    <div class="playerWrap">
      <div id="player"></div>
    </div>
  </div>

  <!-- Top-left status pills -->
  <div id="tv_top_pills" style="position: fixed; left: 16px; top: 16px; display:flex; gap:10px; align-items:center; z-index: 50;">
    <div class="pill">
      <span id="tv_dot" class="dot warn"></span>
      <span id="mode_label">PartyBox</span>
    </div>
    <div id="tv_now_pill" class="pill">
      <span class="muted">Now</span>
      <span id="now_label" class="ellip" style="max-width: 70vw;">—</span>
    </div>
  </div>

  <div id="tv_spotify_banner" class="tvSpotifyBanner hidden" aria-live="polite">
    <span class="dot ok"></span>
    <span id="tv_spotify_banner_text">Spotify Mode Active • Video requests are disabled</span>
  </div>

  <div id="tv_spotify_panel" class="tvSpotifyPanel hidden" aria-live="polite">
    <img id="tv_spotify_art" class="tvSpotifyArt" alt="Album art" />
    <div class="tvSpotifyMeta">
      <div class="tvSpotifyKicker">Now Playing</div>
      <div id="tv_spotify_track" class="tvSpotifyTrack">—</div>
      <div id="tv_spotify_artist" class="tvSpotifyArtist">—</div>
      <div id="tv_spotify_album" class="tvSpotifyAlbum">—</div>
      <div class="tvSpotifyProgress">
        <div id="tv_spotify_progress_fill" class="tvSpotifyProgressFill"></div>
      </div>
      <div class="tvSpotifyTimes">
        <span id="tv_spotify_elapsed">0:00</span>
        <span id="tv_spotify_total">0:00</span>
      </div>
    </div>
  </div>

  <!-- QR prompt surfaces -->
  <div id="tv_qr_idle" class="tvQr tvQrIdle hidden" aria-hidden="true">
    <div class="tvQrTitle">Scan To Pick The Next Video</div>
    <div id="tv_qr_idle_code" class="tvQrCode"></div>
    <div class="tvQrSub" id="tv_qr_idle_sub">Join the same Wi-Fi, then open /user on your phone</div>
  </div>

  <div id="paused_overlay" class="paused-overlay" aria-hidden="true"></div>
  <div id="paused_bar" class="paused-bar" aria-hidden="true">
    <div class="paused-bar-left">
      <div class="paused-kicker">PAUSED</div>
      <div class="paused-reason" id="paused_reason">Admin paused playback</div>
    </div>
    <span class="badge paused">Paused</span>
  </div>

  <script src="/static/qrcode.min.js"></script>
  <script>
    let STATE = null;
    let QR_READY = false;
    const CANONICAL_JOIN_HOST = "partybox.local";
    const LOOPBACK_HOSTS = new Set(["127.0.0.1", "localhost", "::1"]);
    let SPOTIFY_PROGRESS = {
      active: false,
      trackKey: "",
      baseMs: 0,
      durationMs: 0,
      playing: false,
      capturedAtMs: 0
    };

    const el = (id) => document.getElementById(id);

    function getJoinUrl() {
      const host = (window.location.hostname || "").toLowerCase();
      const joinHost = LOOPBACK_HOSTS.has(host) ? CANONICAL_JOIN_HOST : (window.location.host || CANONICAL_JOIN_HOST);
      return `http://${joinHost}/user`;
    }

    function ensureQr() {
      if (QR_READY) return;
      if (typeof window.QRCode !== "function") return;

      const joinUrl = getJoinUrl();
      const shortJoin = joinUrl.replace(/^https?:\/\//, "");
      el("tv_qr_idle_sub").textContent = `Join the same Wi-Fi, then open ${shortJoin}`;

      new window.QRCode(el("tv_qr_idle_code"), {
        text: joinUrl,
        width: 220,
        height: 220,
        correctLevel: window.QRCode.CorrectLevel.H
      });

      const codeEl = el("tv_qr_idle_code");
      if (codeEl && !codeEl.querySelector(".tvQrCenterLogo")) {
        const logo = document.createElement("img");
        logo.className = "tvQrCenterLogo";
        logo.src = "/static/Partybox_favicon.png";
        logo.alt = "PartyBox";
        codeEl.appendChild(logo);
      }

      QR_READY = true;
    }

    function setModePill(mode, tvOnline, avMode) {
      const dot = el("tv_dot");
      dot.classList.remove("ok","warn","bad");

      // color rules
      if ((avMode || "").toLowerCase() === "spotify") dot.classList.add("ok");
      else if (!tvOnline) dot.classList.add("bad");
      else if (mode === "paused") dot.classList.add("warn");
      else dot.classList.add("ok");

      // Keep wording aligned with Admin/User mode pills.
      let label = "Mode: PartyBox";
      if ((avMode || "").toLowerCase() === "spotify") label = "Mode: Spotify";
      else if (mode === "paused") label = "Mode: PartyBox • Paused";

      el("mode_label").textContent = label;
    }

    function setPausedUi(show, reasonText) {
      const overlay = el("paused_overlay");
      const bar = el("paused_bar");
      const reason = el("paused_reason");
      if (reasonText) reason.textContent = reasonText;

      overlay.classList.toggle("show", !!show);
      bar.classList.toggle("show", !!show);
      document.body.classList.toggle("is-paused", !!show);
    }

    function fmtMs(ms) {
      const total = Math.max(0, Math.floor((Number(ms) || 0) / 1000));
      const m = Math.floor(total / 60);
      const s = total % 60;
      return `${m}:${String(s).padStart(2, "0")}`;
    }

    function getInterpolatedProgressMs() {
      if (!SPOTIFY_PROGRESS.active) return 0;
      let progress = SPOTIFY_PROGRESS.baseMs;
      if (SPOTIFY_PROGRESS.playing) {
        progress += (Date.now() - SPOTIFY_PROGRESS.capturedAtMs);
      }
      if (SPOTIFY_PROGRESS.durationMs > 0) {
        progress = Math.min(progress, SPOTIFY_PROGRESS.durationMs);
      }
      return Math.max(0, progress);
    }

    function setSpotifyProgressSnapshot(trackKey, progressMs, durationMs, playing) {
      const nextProgress = Math.max(0, Number(progressMs) || 0);
      const nextDuration = Math.max(0, Number(durationMs) || 0);
      const now = Date.now();
      const sameTrack = !!(SPOTIFY_PROGRESS.active && SPOTIFY_PROGRESS.trackKey && SPOTIFY_PROGRESS.trackKey === trackKey);
      const currentProgress = getInterpolatedProgressMs();

      let baseProgress = nextProgress;
      // Avoid visual jitter: keep progress monotonic for the same playing track unless this looks like a real seek.
      if (sameTrack && playing && SPOTIFY_PROGRESS.playing) {
        const backwardsBy = currentProgress - nextProgress;
        const seekBackThresholdMs = 15000;
        if (backwardsBy > 0 && backwardsBy < seekBackThresholdMs) {
          baseProgress = currentProgress;
        }
      }

      SPOTIFY_PROGRESS = {
        active: true,
        trackKey: trackKey || "",
        baseMs: baseProgress,
        durationMs: nextDuration,
        playing: !!playing,
        capturedAtMs: now
      };
    }

    function renderSpotifyProgress() {
      if (!SPOTIFY_PROGRESS.active) return;
      const duration = SPOTIFY_PROGRESS.durationMs;
      const progress = getInterpolatedProgressMs();

      const pct = duration > 0 ? (progress / duration) * 100 : 0;
      el("tv_spotify_progress_fill").style.width = `${pct}%`;
      el("tv_spotify_elapsed").textContent = fmtMs(progress);
      el("tv_spotify_total").textContent = fmtMs(duration);
    }

    function updateSpotifyUi(av) {
      const banner = el("tv_spotify_banner");
      const bannerText = el("tv_spotify_banner_text");
      const panel = el("tv_spotify_panel");

      const s = STATE && STATE.spotify ? STATE.spotify : null;
      const hasTrack = !!(s && s.track && s.track.name);
      const hasMeta = !!(s && (
        ((s.track || {}).album) ||
        (((s.device || {}).name) || "") ||
        (((s.account || {}).display_name) || "") ||
        (s.error || "")
      ));
      const active = !!(s && ((s.state === "playing" || s.state === "paused") || hasTrack || hasMeta));
      const acctName = s && s.account && s.account.display_name ? s.account.display_name : "";
      const acct = acctName ? ` • Spotify Account: ${acctName}` : "";

      if (av !== "spotify") {
        banner.classList.add("hidden");
        panel.classList.add("hidden");
        document.body.classList.remove("spotify-mode");
        el("tv_top_pills").style.display = "flex";
        return;
      }

      document.body.classList.add("spotify-mode");
      el("tv_top_pills").style.display = "none";
      bannerText.textContent = `Spotify Mode Active${acct}`;
      banner.classList.remove("hidden");
      panel.classList.remove("hidden");

      const track = s.track || {};
      const images = s.images || {};
      const art = images.large || images.medium || images.small || "";
      const artists = Array.isArray(track.artists) ? track.artists.join(", ") : "";
      const duration = Number(track.duration_ms) || 0;
      const progress = Math.max(0, Math.min(Number(s.progress_ms) || 0, duration || Number(s.progress_ms) || 0));
      const err = (s && s.error) ? String(s.error) : "";
      const device = ((s && s.device && s.device.name) ? String(s.device.name) : "");
      const playbackLabel = (s && (s.state === "playing" || s.state === "paused"))
        ? String(s.state).charAt(0).toUpperCase() + String(s.state).slice(1)
        : "Waiting";
      const isPlaying = !!(s && s.state === "playing");
      const trackId = (track && track.id) ? String(track.id) : "";
      const trackKey = trackId || [
        (track.name || "").trim(),
        artists,
        (track.album || "").trim(),
        String(duration || 0),
      ].join("|");

      if (!active) {
        el("tv_spotify_track").textContent = "Waiting for Spotify metadata";
        el("tv_spotify_artist").textContent = err ? `Spotify API: ${err}` : "Start playback on PartyBox device";
        el("tv_spotify_album").textContent = device ? `Device: ${device}` : playbackLabel;
      } else {
        el("tv_spotify_track").textContent = track.name || "Unknown track";
        el("tv_spotify_artist").textContent = artists || (err ? `Spotify API: ${err}` : "Unknown artist");
        el("tv_spotify_album").textContent = track.album || (device ? `Device: ${device}` : playbackLabel);
      }
      el("tv_spotify_art").src = art;
      el("tv_spotify_art").style.visibility = art ? "visible" : "hidden";
      setSpotifyProgressSnapshot(trackKey, progress, duration, isPlaying);
      renderSpotifyProgress();
    }

    function updateFromState(tvOnline) {
      if (!STATE) return;
      ensureQr();

      const av = (STATE.av_mode || "partybox").toLowerCase();
      const paused = !!STATE.paused;
      const mode = (STATE.mode || "").toLowerCase();
      const now = STATE.now || null;
      const qrEnabled = !!(STATE.tv_qr_enabled ?? true);

      const nowTitle = (now && now.title) ? now.title : "—";
      el("now_label").textContent = nowTitle;
      updateSpotifyUi(av);
      if (av !== "spotify") el("tv_now_pill").style.display = "";

      setModePill(mode, tvOnline, av);

      const partyboxMode = av !== "spotify";
      const idlePartybox = qrEnabled && partyboxMode && !paused && mode === "empty";

      el("tv_qr_idle").classList.toggle("hidden", !idlePartybox);

      if (paused && av !== "spotify") {
        const reason = STATE.now ? "PartyBox playback is paused. Resume to continue this selection." : "PartyBox playback is paused by Admin.";
        setPausedUi(true, reason);
        return;
      }

      setPausedUi(false);
    }

    async function pollTvStatus() {
      // Single endpoint for TV: includes both heartbeat and state.
      try {
        const r = await fetch("/api/tv/status", { cache: "no-store" });
        const j = await r.json();
        const st = (j && j.ok) ? j.status : null;
        STATE = (j && j.ok && j.state) ? j.state : null;
        const now = Math.floor(Date.now() / 1000);
        const online = !!(st && st.ts && (now - st.ts) <= 15);
        updateFromState(online);
      } catch (e) {
        // if we can’t read tv/status, assume offline indicator but still show state info
        updateFromState(false);
      }
    }

    async function tick() {
      await pollTvStatus();
    }

    tick();
    setInterval(tick, 3000);
    setInterval(() => {
      if (!STATE) return;
      if ((STATE.av_mode || "").toLowerCase() !== "spotify") return;
      renderSpotifyProgress();
    }, 250);
  </script>
</body>
</html>
