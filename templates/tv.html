<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PartyBox TV</title>
  <style>
    html, body { margin:0; padding:0; background:#000; height:100%; overflow:hidden; }
    #wrap { position:relative; width:100%; height:100%; }
    #vid { width:100%; height:100%; object-fit:contain; background:#000; }
    #msg {
      position:absolute; left:0; right:0; top:0;
      padding:16px 20px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:#fff;
      background: linear-gradient(rgba(0,0,0,0.65), rgba(0,0,0,0));
      font-size: 18px;
      text-shadow: 0 2px 10px rgba(0,0,0,0.9);
    }
    #note {
      position:absolute; left:0; right:0; bottom:0;
      padding:18px 22px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:#fff;
      background: linear-gradient(rgba(0,0,0,0), rgba(0,0,0,0.65));
      font-size: 22px;
      display:none;
      text-shadow: 0 2px 10px rgba(0,0,0,0.9);
    }
  </style>
</head>
<body>
<div id="wrap">
  <video id="vid" playsinline autoplay></video>
  <div id="msg">PartyBox TV — waiting…</div>
  <div id="note"></div>
</div>

<script>
const vid  = document.getElementById("vid");
const msg  = document.getElementById("msg");
const note = document.getElementById("note");

let playingLock = null;   // { youtube_id, queue_id|null, mode }
let lastState = null;

function isLocalToken(yid) {
  return (yid || "").startsWith("file:");
}
function localFilenameFromToken(yid) {
  return (yid || "").slice("file:".length).trim();
}

async function api(path, opts={}) {
  const r = await fetch(path, Object.assign({cache:"no-store"}, opts));
  if (!r.ok) throw new Error(`${path} -> ${r.status}`);
  return await r.json();
}

function setBanner(state) {
  const now = state.now;
  const up  = state.up_next;

  if (state.paused) {
    msg.textContent = now ? `PAUSED — ${now.title}` : "PAUSED — PartyBox TV";
    return;
  }

  if (!now) {
    msg.textContent = "PartyBox TV — no videos available";
    return;
  }

  if (state.mode === "playing" || state.mode === "queue") {
    if (up && up.title) msg.textContent = `Now: ${now.title}   •   Up next: ${up.title}`;
    else msg.textContent = `Now: ${now.title}`;
  } else {
    msg.textContent = `Idle: ${now.title}`;
  }
}

function setNote(text) {
  const t = (text || "").trim();
  if (t) {
    note.textContent = t;
    note.style.display = "block";
  } else {
    note.style.display = "none";
  }
}

function forceStopAndUnlock() {
  try { vid.pause(); } catch (_) {}
  try { vid.removeAttribute("src"); vid.load(); } catch (_) {}
  playingLock = null;
}

async function tryStartLocal(state) {
  const now = state.now;
  const fn  = localFilenameFromToken(now.youtube_id);
  const src = `/media/${encodeURIComponent(fn)}`;

  vid.src = src;
  vid.load();

  const desiredMuted = !!state.muted;
  vid.muted = desiredMuted;

  const p = vid.play();
  if (p) {
    p.catch(() => {
      if (!desiredMuted) {
        vid.muted = true;
        vid.play().catch(()=>{});
      }
    });
  }

  // mark playing if queue item
  if ((state.mode === "queue" || state.mode === "playing") && now.queue_id) {
    fetch("/api/tv/mark_playing", {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({queue_id: now.queue_id})
    }).catch(()=>{});
  }
}

async function skipYouTubeIfQueued(state) {
  const now = state.now;
  msg.textContent = `Cannot play YouTube item here — skipping: ${now.title}`;
  setNote("");

  if (now.queue_id) {
    await fetch("/api/tv/mark_done", {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({queue_id: now.queue_id})
    }).catch(()=>{});
  }
}

async function poll() {
  try {
    const state = await api("/api/state");
    lastState = state;

    // Pause behavior
    if (state.paused) {
      setBanner(state);
      setNote("");
      if (!vid.paused) vid.pause();
      return;
    }

    // Nothing to do
    if (!state.now) {
      setBanner(state);
      setNote("");
      if (!vid.paused) vid.pause();
      return;
    }

    setBanner(state);
    setNote(state.now.note_text || "");

    // NEW: if admin skipped/changed "now", break the lock immediately
    if (playingLock && state.now) {
      const serverQid = state.now.queue_id || null;
      const serverYid = state.now.youtube_id || "";
      const lockQid   = playingLock.queue_id || null;
      const lockYid   = playingLock.youtube_id || "";

      const serverAdvanced =
        (lockQid && serverQid && serverQid !== lockQid) ||
        (!lockQid && serverQid) ||
        (serverYid && lockYid && serverYid !== lockYid);

      if (serverAdvanced) {
        forceStopAndUnlock();
      }
    }

    // LOCK: if a video is currently playing, do NOT switch until it ends.
    if (playingLock && !vid.paused && !vid.ended) {
      return;
    }

    const now = state.now;

    // New lock target
    playingLock = { youtube_id: now.youtube_id, queue_id: now.queue_id || null, mode: state.mode };

    if (isLocalToken(now.youtube_id)) {
      await tryStartLocal(state);
      return;
    }

    await skipYouTubeIfQueued(state);

  } catch (e) {
    msg.textContent = `TV error: ${e}`;
  }
}

vid.addEventListener("ended", async () => {
  try {
    if (playingLock && playingLock.queue_id) {
      await fetch("/api/tv/mark_done", {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({queue_id: playingLock.queue_id})
      });
    }
  } catch (_) {}

  playingLock = null;
});

setInterval(poll, 1000);
poll();
</script>
</body>
</html>
