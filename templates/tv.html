{% extends "base.html" %}
{% block body %}
<div class="tv">
  <div id="playerWrap" class="playerWrap">
    <div id="player"></div>
  </div>
  <div id="toast" class="toast hidden"></div>
</div>

<script src="https://www.youtube.com/iframe_api"></script>
{% endblock %}

{% block scripts %}
<script>
  let ytPlayer = null;

  let currentQueueId = null;
  let currentVideoId = null;
  let suppressUntil = 0;

  // Next candidate from server (/api/state)
  window.__next = null;

  function showToast(msg) {
    const el = document.getElementById('toast');
    el.textContent = msg;
    el.classList.remove('hidden');
    setTimeout(() => el.classList.add('hidden'), 3500);
  }

  function api(path, body) {
    return fetch(path, {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify(body || {})
    }).then(r => r.json());
  }

  function pollState() {
    if (Date.now() < suppressUntil) return;

    fetch('/api/state')
      .then(r => r.json())
      .then(st => {
        if (!st.next) return;

        const nxt = st.next;

        // If we're already playing this exact video, do nothing
        if (currentVideoId === nxt.youtube_id) return;

        // Always keep a candidate next (queue or idle)
        window.__next = { ...nxt, mode: st.mode || "queue" };

        if ((st.mode || "queue") === "queue") {
          showToast("Next selected: " + nxt.title);
        }
      })
      .catch(() => {});
  }

  function playVideoId(videoId) {
    currentVideoId = videoId;
    if (!ytPlayer) return;

    // Autoplay is most reliable when muted.
    ytPlayer.mute();
    ytPlayer.loadVideoById(videoId);
  }

  function startNextIfAvailable() {
    const nxt = window.__next || null;
    if (!nxt) return;

    // Queue item vs idle item
    if (nxt.queue_id) {
      currentQueueId = nxt.queue_id;
      api('/api/tv/mark_playing', {queue_id: currentQueueId}).then(() => {});
      if (nxt.note_text) showToast(nxt.note_text);
    } else {
      currentQueueId = null;
    }

    playVideoId(nxt.youtube_id);
    window.__next = null;
  }

  function finishAndAdvance(reason) {
    if (reason) showToast(reason);

    // Mark done if it was a queued item
    if (currentQueueId) {
      api('/api/tv/mark_done', {queue_id: currentQueueId}).then(() => {});
      currentQueueId = null;
    }

    suppressUntil = Date.now() + 800;
    // Immediately try another
    startNextIfAvailable();
  }

  function onYouTubeIframeAPIReady() {
    ytPlayer = new YT.Player('player', {
      width: '100%',
      height: '100%',
      videoId: '',
      playerVars: {
        autoplay: 1,
        controls: 0,
        rel: 0,
        modestbranding: 1,
        playsinline: 1
      },
      events: {
        onReady: () => {
          // Poll for next/idle
          setInterval(pollState, 2000);

          // If nothing is playing, start something (idle or queued)
          setInterval(() => {
            try {
              const state = ytPlayer.getPlayerState();
              if (state !== YT.PlayerState.PLAYING && state !== YT.PlayerState.BUFFERING) {
                startNextIfAvailable();
              }
            } catch (e) {}
          }, 1500);
        },

        onStateChange: (e) => {
          if (e.data === YT.PlayerState.PLAYING) {
            // Try to unmute after playback starts (may be blocked by browser policy)
            try { ytPlayer.unMute(); } catch (err) {}
          }

          if (e.data === YT.PlayerState.ENDED) {
            finishAndAdvance(null);
          }
        },

        onError: (err) => {
          const code = (err && err.data) ? err.data : null;
          // 101/150 are commonly "embed disabled"
          const msg = (code === 101 || code === 150)
            ? "Video blocked (embed). Skipping…"
            : "Playback error. Skipping…";
          finishAndAdvance(msg);
        }
      }
    });
  }
</script>
{% endblock %}
