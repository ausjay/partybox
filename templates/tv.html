<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TV — PartyBox</title>
  <link rel="icon" href="/static/favicon.webp" type="image/webp" />
  <link rel="apple-touch-icon" href="/static/partybox_logo.webp" />
  <link rel="stylesheet" href="/static/style.css" />
</head>

<body class="tvPage">
  <div class="tv">
    <video class="tvBgVideo" autoplay muted loop playsinline preload="auto" aria-hidden="true">
      <source src="/static/partybox_animated_background.mp4" type="video/mp4" />
    </video>
    <img class="tvCenterLogo" src="/static/partybox_t.png" alt="PartyBox" />
    <img id="tv_mode_logo" class="tvModeLogo" src="/static/partybox_t.png" alt="PartyBox" />
    <div class="playerWrap">
      <div id="player"></div>
    </div>
  </div>

  <!-- Top-right status pills -->
  <div id="tv_top_pills" class="tvTopPills">
    <div class="pill">
      <span id="tv_dot" class="dot warn"></span>
      <span id="mode_label">Mode: PartyBox</span>
    </div>
    <div class="pill">
      <span id="tv_status_dot" class="dot warn"></span>
      <span id="tv_status_label">Status: Idle</span>
    </div>
  </div>

  <div id="tv_spotify_panel" class="tvSpotifyPanel hidden" aria-live="polite">
    <img id="tv_spotify_art" class="tvSpotifyArt" alt="Album art" />
    <div class="tvSpotifyMeta">
      <div class="tvSpotifyKicker">Now Playing</div>
      <div id="tv_spotify_track" class="tvSpotifyTrack">—</div>
      <div id="tv_spotify_artist" class="tvSpotifyArtist">—</div>
      <div id="tv_spotify_album" class="tvSpotifyAlbum">—</div>
      <div class="tvSpotifyProgress">
        <div id="tv_spotify_progress_fill" class="tvSpotifyProgressFill"></div>
      </div>
      <div class="tvSpotifyTimes">
        <span id="tv_spotify_elapsed">0:00</span>
        <span id="tv_spotify_total">0:00</span>
      </div>
    </div>
  </div>

  <!-- QR prompt surfaces -->
  <div id="tv_qr_idle" class="tvQr tvQrIdle hidden" aria-hidden="true">
    <div class="tvQrTitle">Scan To Pick The Next Video</div>
    <div id="tv_qr_idle_code" class="tvQrCode"></div>
    <div class="tvQrSub" id="tv_qr_idle_sub">Join the same Wi-Fi, then open /user on your phone</div>
  </div>

  <div id="paused_overlay" class="paused-overlay" aria-hidden="true"></div>
  <div id="paused_bar" class="paused-bar" aria-hidden="true">
    <div class="paused-bar-left">
      <div class="paused-kicker">PAUSED</div>
      <div class="paused-reason" id="paused_reason">Admin paused playback</div>
    </div>
    <span class="badge paused">Paused</span>
  </div>
  <div id="tv_mode_banner" class="tvModeBanner hidden" aria-live="polite">
    <img id="tv_mode_banner_icon" class="tvModeBannerIcon" src="" alt="" />
    <div class="tvModeBannerLeft">
      <div id="tv_mode_banner_kicker" class="tvModeBannerKicker">TV Mode Active</div>
      <div id="tv_mode_banner_text" class="tvModeBannerText">PartyBox playback is paused while TV mode is active.</div>
    </div>
  </div>

  <script src="/static/qrcode.min.js"></script>
  <script>
    let STATE = null;
    let QR_READY = false;
    const CANONICAL_JOIN_HOST = "partybox.local";
    const LOOPBACK_HOSTS = new Set(["127.0.0.1", "localhost", "::1"]);
    let SPOTIFY_PROGRESS = {
      active: false,
      trackKey: "",
      baseMs: 0,
      durationMs: 0,
      playing: false,
      capturedAtMs: 0
    };

    const el = (id) => document.getElementById(id);

    function getJoinUrl() {
      const host = (window.location.hostname || "").toLowerCase();
      const joinHost = LOOPBACK_HOSTS.has(host) ? CANONICAL_JOIN_HOST : (window.location.host || CANONICAL_JOIN_HOST);
      return `http://${joinHost}/user`;
    }

    function ensureQr() {
      if (QR_READY) return;
      if (typeof window.QRCode !== "function") return;

      const joinUrl = getJoinUrl();
      const shortJoin = joinUrl.replace(/^https?:\/\//, "");
      el("tv_qr_idle_sub").textContent = `Join the same Wi-Fi, then open ${shortJoin}`;

      new window.QRCode(el("tv_qr_idle_code"), {
        text: joinUrl,
        width: 220,
        height: 220,
        correctLevel: window.QRCode.CorrectLevel.H
      });

      const codeEl = el("tv_qr_idle_code");
      if (codeEl && !codeEl.querySelector(".tvQrCenterLogo")) {
        const logo = document.createElement("img");
        logo.className = "tvQrCenterLogo";
        logo.src = "/static/Partybox_favicon.png";
        logo.alt = "PartyBox";
        codeEl.appendChild(logo);
      }

      QR_READY = true;
    }

    function setModePill(mode, mediaMode) {
      const dot = el("tv_dot");
      dot.classList.remove("ok","warn","bad");

      const mm = String(mediaMode || "partybox").toLowerCase();
      if (mm === "mute") dot.classList.add("warn");
      else dot.classList.add("ok");

      let label = "Mode: PartyBox";
      if (mm === "spotify") label = "Mode: Spotify";
      else if (mm === "airplay") label = "Mode: AirPlay";
      else if (mm === "bluetooth") label = "Mode: Bluetooth";
      else if (mm === "tv") label = "Mode: TV";
      else if (mm === "mute") label = "Mode: Mute";

      el("mode_label").textContent = label;
    }

    function setStatusPill(mode, mediaMode, paused, muted, externalNow) {
      const dot = el("tv_status_dot");
      const label = el("tv_status_label");
      dot.classList.remove("ok", "warn", "bad");

      const mm = String(mediaMode || "partybox").toLowerCase();
      const playbackMode = String(mode || "").toLowerCase();
      const isPaused = !!paused || playbackMode === "paused";
      const isMuted = !!muted || mm === "mute";
      const ext = (externalNow && typeof externalNow === "object") ? externalNow : {};
      const btCur = (ext.bluetooth && typeof ext.bluetooth === "object") ? ext.bluetooth : {};
      const btDevice = String(btCur.device_name || "").trim();

      let statusText = "Idle";
      if (mm === "mute") {
        statusText = "Muted";
      } else if (mm === "bluetooth" && btDevice) {
        statusText = `Bluetooth Active • ${btDevice}`;
      } else if (mm !== "partybox") {
        const pretty = String(el("mode_label").textContent || "Mode: PartyBox").replace("Mode: ", "");
        statusText = `${pretty} Active`;
      } else if (isPaused) {
        statusText = "Paused";
      } else if (playbackMode === "playing") {
        statusText = "Playing";
      } else if (playbackMode === "queue") {
        statusText = "Queued";
      }

      if (isMuted && statusText !== "Muted") statusText = `${statusText} • Muted`;
      if (isMuted) dot.classList.add("warn");
      else if (mm !== "partybox" || playbackMode === "playing") dot.classList.add("ok");
      else if (isPaused || playbackMode === "queue" || playbackMode === "empty") dot.classList.add("warn");
      else dot.classList.add("ok");
      label.textContent = `Status: ${statusText}`;
    }

    function setPausedUi(show, reasonText) {
      const overlay = el("paused_overlay");
      const bar = el("paused_bar");
      const reason = el("paused_reason");
      if (reasonText) reason.textContent = reasonText;

      overlay.classList.toggle("show", !!show);
      bar.classList.toggle("show", !!show);
      document.body.classList.toggle("is-paused", !!show);
    }

    function setModeBanner(mediaMode, externalNow, playbackMode, paused, nowItem) {
      const banner = el("tv_mode_banner");
      if (!banner) return;
      const icon = el("tv_mode_banner_icon");
      const kicker = el("tv_mode_banner_kicker");
      const text = el("tv_mode_banner_text");
      const mm = String(mediaMode || "partybox").toLowerCase();
      const pm = String(playbackMode || "").toLowerCase();
      const isPaused = !!paused;
      const now = (nowItem && typeof nowItem === "object") ? nowItem : {};
      const ext = (externalNow && typeof externalNow === "object") ? externalNow : {};
      const extCur = (ext[mm] && typeof ext[mm] === "object") ? ext[mm] : {};

      let next = null;
      if (mm === "partybox") {
        const nowTitle = String(now.title || "").trim();
        if ((pm === "playing" || isPaused) && nowTitle) {
          const pbText = isPaused ? `Paused: ${nowTitle}` : nowTitle;
          next = {
            kicker: "PartyBox Now Playing",
            text: pbText,
            icon: "/static/Partybox_favicon.png",
            iconAlt: "PartyBox mode",
          };
        }
      } else if (mm === "tv") {
        next = {
          kicker: "TV Mode Active",
          text: "PartyBox queue playback is paused while TV audio mode is active.",
          icon: "/static/mode_tv.jpg",
          iconAlt: "TV mode",
        };
      } else if (mm === "bluetooth") {
        const btTitle = String(extCur.title || "").trim();
        const btArtist = String(extCur.artist || "").trim();
        const btDevice = String(extCur.device_name || "").trim();
        const btActive = !!extCur.active;
        const btMeta = !!extCur.metadata_available;
        let btText = "Bluetooth receiver is ready. Stream audio to \"PartyBox BT\".";
        if (btActive && btMeta && btTitle) {
          btText = btArtist ? `${btTitle} — ${btArtist}` : btTitle;
        } else if (btActive) {
          btText = btDevice ? `Streaming from ${btDevice} (metadata unavailable)` : "Bluetooth audio active (metadata unavailable)";
        } else if (btDevice) {
          btText = `Connected: ${btDevice}. Start playback to stream audio.`;
        }
        next = {
          kicker: "Bluetooth Mode Active",
          text: btText,
          icon: "/static/mode_bluetooth.png",
          iconAlt: "Bluetooth mode",
        };
      } else if (mm === "airplay") {
        const apTitle = String(extCur.title || "").trim();
        const apArtist = String(extCur.artist || "").trim();
        const apActive = !!extCur.active;
        const apMeta = !!extCur.metadata_available;
        let apText = "AirPlay receiver is ready. Cast audio to \"PartyBox\".";
        if (apActive && apMeta && apTitle) {
          apText = apArtist ? `${apTitle} — ${apArtist}` : apTitle;
        } else if (apActive) {
          apText = "AirPlay audio active (metadata unavailable)";
        }
        next = {
          kicker: "AirPlay Mode Active",
          text: apText,
          icon: "/static/mode_airplay.png",
          iconAlt: "AirPlay mode",
        };
      }

      if (!next) {
        banner.classList.add("hidden");
        return;
      }

      if (icon) {
        icon.src = next.icon || "";
        icon.alt = next.iconAlt || "";
      }
      kicker.textContent = next.kicker;
      text.textContent = next.text;
      banner.classList.remove("hidden");
    }

    function fmtMs(ms) {
      const total = Math.max(0, Math.floor((Number(ms) || 0) / 1000));
      const m = Math.floor(total / 60);
      const s = total % 60;
      return `${m}:${String(s).padStart(2, "0")}`;
    }

    function getInterpolatedProgressMs() {
      if (!SPOTIFY_PROGRESS.active) return 0;
      let progress = SPOTIFY_PROGRESS.baseMs;
      if (SPOTIFY_PROGRESS.playing) {
        progress += (Date.now() - SPOTIFY_PROGRESS.capturedAtMs);
      }
      if (SPOTIFY_PROGRESS.durationMs > 0) {
        progress = Math.min(progress, SPOTIFY_PROGRESS.durationMs);
      }
      return Math.max(0, progress);
    }

    function setSpotifyProgressSnapshot(trackKey, progressMs, durationMs, playing) {
      const nextProgress = Math.max(0, Number(progressMs) || 0);
      const nextDuration = Math.max(0, Number(durationMs) || 0);
      const now = Date.now();
      const sameTrack = !!(SPOTIFY_PROGRESS.active && SPOTIFY_PROGRESS.trackKey && SPOTIFY_PROGRESS.trackKey === trackKey);
      const currentProgress = getInterpolatedProgressMs();

      let baseProgress = nextProgress;
      // Avoid visual jitter: keep progress monotonic for the same playing track unless this looks like a real seek.
      if (sameTrack && playing && SPOTIFY_PROGRESS.playing) {
        const backwardsBy = currentProgress - nextProgress;
        const seekBackThresholdMs = 15000;
        if (backwardsBy > 0 && backwardsBy < seekBackThresholdMs) {
          baseProgress = currentProgress;
        }
      }

      SPOTIFY_PROGRESS = {
        active: true,
        trackKey: trackKey || "",
        baseMs: baseProgress,
        durationMs: nextDuration,
        playing: !!playing,
        capturedAtMs: now
      };
    }

    function renderSpotifyProgress() {
      if (!SPOTIFY_PROGRESS.active) return;
      const duration = SPOTIFY_PROGRESS.durationMs;
      const progress = getInterpolatedProgressMs();

      const pct = duration > 0 ? (progress / duration) * 100 : 0;
      el("tv_spotify_progress_fill").style.width = `${pct}%`;
      el("tv_spotify_elapsed").textContent = fmtMs(progress);
      el("tv_spotify_total").textContent = fmtMs(duration);
    }

    function updateSpotifyUi(mediaMode) {
      const panel = el("tv_spotify_panel");

      const s = STATE && STATE.spotify ? STATE.spotify : null;
      const hasTrack = !!(s && s.track && s.track.name);
      const hasMeta = !!(s && (
        ((s.track || {}).album) ||
        (((s.device || {}).name) || "") ||
        (((s.account || {}).display_name) || "") ||
        (s.error || "")
      ));
      const active = !!(s && ((s.state === "playing" || s.state === "paused") || hasTrack || hasMeta));
      if (String(mediaMode || "").toLowerCase() !== "spotify") {
        panel.classList.add("hidden");
        document.body.classList.remove("spotify-mode");
        el("tv_top_pills").style.display = "flex";
        return;
      }

      document.body.classList.add("spotify-mode");
      el("tv_top_pills").style.display = "flex";
      panel.classList.remove("hidden");

      const track = s.track || {};
      const images = s.images || {};
      const art = images.large || images.medium || images.small || "";
      const artists = Array.isArray(track.artists) ? track.artists.join(", ") : "";
      const duration = Number(track.duration_ms) || 0;
      const progress = Math.max(0, Math.min(Number(s.progress_ms) || 0, duration || Number(s.progress_ms) || 0));
      const err = (s && s.error) ? String(s.error) : "";
      const device = ((s && s.device && s.device.name) ? String(s.device.name) : "");
      const uiState = (s && s.ui_state) ? String(s.ui_state).toLowerCase() : "";
      const uiMessage = (s && s.ui_message) ? String(s.ui_message) : "";
      const connectHint = (s && s.connect_hint) ? String(s.connect_hint) : "";
      const playbackLabel = (s && (s.state === "playing" || s.state === "paused"))
        ? String(s.state).charAt(0).toUpperCase() + String(s.state).slice(1)
        : "Waiting";
      const isPlaying = !!(s && s.state === "playing");
      const trackId = (track && track.id) ? String(track.id) : "";
      const trackKey = trackId || [
        (track.name || "").trim(),
        artists,
        (track.album || "").trim(),
        String(duration || 0),
      ].join("|");

      if (uiState === "playing_on_partybox" && hasTrack) {
        el("tv_spotify_track").textContent = track.name || "Unknown track";
        el("tv_spotify_artist").textContent = artists || (err ? `Spotify API: ${err}` : "Unknown artist");
        el("tv_spotify_album").textContent = track.album || (device ? `Device: ${device}` : playbackLabel);
      } else {
        const waitingLine = uiMessage || (active ? "Waiting for Spotify Connect..." : "Waiting for Spotify metadata");
        el("tv_spotify_track").textContent = waitingLine;
        if (uiState === "playing_elsewhere" && device) {
          el("tv_spotify_artist").textContent = `Current device: ${device}`;
        } else if (uiState === "rate_limited") {
          el("tv_spotify_artist").textContent = waitingLine;
        } else {
          el("tv_spotify_artist").textContent = connectHint || (err ? `Spotify API: ${err}` : "Start playback on PartyBox device");
        }
        el("tv_spotify_album").textContent = err && uiState !== "rate_limited"
          ? `Spotify API: ${err}`
          : (device ? `Device: ${device}` : playbackLabel);
      }
      el("tv_spotify_art").src = art;
      el("tv_spotify_art").style.visibility = art ? "visible" : "hidden";
      setSpotifyProgressSnapshot(trackKey, progress, duration, isPlaying);
      renderSpotifyProgress();
    }

    function updateFromState() {
      if (!STATE) return;
      ensureQr();

      const mediaMode = (STATE.media_mode || "partybox").toLowerCase();
      const paused = !!STATE.paused;
      const muted = !!STATE.muted;
      const mode = (STATE.mode || "").toLowerCase();
      const qrEnabled = !!(STATE.tv_qr_enabled ?? true);
      const externalNow = STATE.external_now_playing || {};

      updateSpotifyUi(mediaMode);

      setModePill(mode, mediaMode);
      setStatusPill(mode, mediaMode, paused, muted, externalNow);
      setModeBanner(mediaMode, externalNow, mode, paused, STATE.now || null);

      const partyboxMode = mediaMode === "partybox";
      const idlePartybox = qrEnabled && partyboxMode && !paused && mode === "empty";

      el("tv_qr_idle").classList.toggle("hidden", !idlePartybox);

      if (paused && mediaMode === "partybox") {
        const reason = STATE.now ? "PartyBox playback is paused. Resume to continue this selection." : "PartyBox playback is paused by Admin.";
        setPausedUi(true, reason);
        return;
      }

      setPausedUi(false);
    }

    async function pollTvStatus() {
      // Single endpoint for TV: includes both heartbeat and state.
      try {
        const r = await fetch("/api/tv/status", { cache: "no-store" });
        const j = await r.json();
        STATE = (j && j.ok && j.state) ? j.state : null;
        updateFromState();
      } catch (e) {
        // if we can’t read tv/status, keep prior UI state
        updateFromState();
      }
    }

    async function tick() {
      await pollTvStatus();
    }

    tick();
    setInterval(tick, 3000);
    setInterval(() => {
      if (!STATE) return;
      if ((STATE.media_mode || "").toLowerCase() !== "spotify") return;
      renderSpotifyProgress();
    }, 250);
  </script>
</body>
</html>
