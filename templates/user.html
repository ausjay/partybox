<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pick Next Video — PartyBox</title>
  <link rel="icon" href="/static/favicon.webp" type="image/webp" />
  <link rel="apple-touch-icon" href="/static/partybox_logo.webp" />
  <link rel="stylesheet" href="/static/style.css" />
</head>

<body class="userPage">
  <div class="appBg">
    <div class="page">

      <!-- Topbar -->
      <div class="topbar">
        <div class="brandRow">
          <img class="brandWordmark" src="/static/partybox_t.png" alt="PartyBox" />
        </div>

        <div class="topActions">
          <div class="pill" title="Playback mode">
            <span class="dot" id="mode_dot"></span>
            <span id="mode_text">Mode: —</span>
          </div>
          <div id="lock_pill" class="pill" title="Requests lock" style="display:none;">
            <span id="lock_dot" class="dot bad"></span>
            <span id="lock_text">Requests Locked</span>
          </div>
        </div>
      </div>

      <!-- Banners -->
      <div id="spotify_banner" class="pb-banner warn" style="display:none; margin: 12px 0;">
        <div class="title">Spotify Mode</div>
        <div class="sub">Video requests are disabled while Spotify is active.</div>
      </div>

      <div class="grid user-grid" style="margin-top: 12px;">
        <!-- Left: Browse -->
        <div class="panel panel-browse" style="grid-column: span 8;">
          <div class="panelHeader">
            <div>
              <div class="kicker">Catalog</div>
              <div class="hint">Browse and pick the next video to add to the queue.</div>
            </div>

            <div class="btnGroup">
              <button class="btn small ghost" id="btn_refresh">Refresh</button>
            </div>
          </div>

          <div class="panelInner">
            <div class="row">
              <input id="q" class="input" placeholder="Search title..." autocomplete="off" />
              <button class="btn primary" id="btn_search">Search</button>
              <button class="btn ghost" id="btn_clear">Clear</button>
            </div>

            <div style="margin-top: 14px;">
              <h2>Results</h2>
              <div id="results" class="list" style="margin-top: 10px;"></div>
              <div id="no_results" class="muted" style="display:none; margin-top: 10px;">No results.</div>
            </div>
          </div>
        </div>

        <!-- Right: Now / Queue -->
        <div class="panelStack panel-side" style="grid-column: span 4;">
          <div class="panel panel-now">
            <div class="panelHeader">
              <div class="kicker">Now</div>
            </div>

            <div class="panelInner">
              <div class="now-current-block">
                <div class="card">
                  <div class="title" id="now_title">—</div>
                  <div class="sub" id="now_note" style="display:none;"></div>
                </div>
              </div>

              <div class="upnext-stack" style="display:none;">
                <div class="upnext-header section-split">
                  <h2>Up Next</h2>
                  <button id="btn_upnext_toggle" class="btn small ghost">Show all</button>
                </div>
                <div class="muted" id="up_next_empty" style="margin-top: 8px;">Queue is empty.</div>
                <div id="up_next_list" class="list" style="display:none; margin-top: 10px;"></div>
                <div class="muted" id="up_next_more" style="display:none; margin-top: 8px;"></div>
              </div>
            </div>
          </div>

          <div class="panel panel-queue">
            <div class="panelHeader">
              <div>
                <div class="kicker">Queue</div>
                <div class="hint" id="queue_hint">What will play after “Now Playing”</div>
              </div>
            </div>
            <div class="panelInner">
              <div id="queue_list" class="list"></div>
              <div id="queue_empty" class="muted" style="display:none;">Queue is empty.</div>
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>

  <div id="toast" class="pb-toast hidden"></div>

  <script>
    // Server-provided catalog items (enabled only)
    const CATALOG = [
      {% for it in items %}
      {
        id: {{ it["id"]|int }},
        title: {{ (it["title"] or "")|tojson }},
        youtube_id: {{ (it["youtube_id"] or "")|tojson }},
        enabled: {{ 1 if it.get("enabled", True) else 0 }}
      }{% if not loop.last %},{% endif %}
      {% endfor %}
    ];

    // Server-provided initial lock + av_mode (will be overwritten by /api/state polling)
    let LOCKED = {{ "true" if locked else "false" }};
    let AV_MODE = {{ (av_mode or "partybox")|tojson }};

    // UI state
    let STATE = null;
    let UP_NEXT_EXPANDED = false;
    const UP_NEXT_LIMIT = 5;

    const el = (id) => document.getElementById(id);

    function showToast(msg, kind="ok", ms=1800) {
      const t = el("toast");
      t.textContent = msg;
      t.className = `pb-toast ${kind}`;
      t.classList.remove("hidden");
      window.clearTimeout(showToast._timer);
      showToast._timer = window.setTimeout(() => t.classList.add("hidden"), ms);
    }

    function isDisabledForRequests() {
      if (!STATE) return false;
      if (STATE.locked) return true;
      if ((STATE.av_mode || "").toLowerCase() === "spotify") return true;
      return false;
    }

    function renderResults(list) {
      const results = el("results");
      results.innerHTML = "";

      if (!list.length) {
        el("no_results").style.display = "block";
        return;
      }
      el("no_results").style.display = "none";

      const disable = isDisabledForRequests();

      for (const item of list) {
        const row = document.createElement("button");
        row.type = "button";
        row.className = "listrow catalog-row";
        row.style.cursor = disable ? "not-allowed" : "pointer";
        row.disabled = disable;

        const left = document.createElement("div");
        left.className = "grow";

        const titleLine = document.createElement("div");
        titleLine.className = "catalog-title-line";

        const badge = document.createElement("span");
        badge.className = "badge catalog-add-badge";
        badge.textContent = "Add";

        const title = document.createElement("div");
        title.className = "title ellip catalog-title";
        title.textContent = item.title || "(untitled)";

        titleLine.appendChild(badge);
        titleLine.appendChild(title);
        left.appendChild(titleLine);

        row.appendChild(left);

        row.addEventListener("click", () => requestVideo(item.id));

        results.appendChild(row);
      }
    }

    function filterCatalog() {
      const q = (el("q").value || "").trim().toLowerCase();
      if (!q) return CATALOG.slice();
      return CATALOG.filter(it => (it.title || "").toLowerCase().includes(q));
    }

    async function requestVideo(catalogId) {
      // Keep paused informational only: allow queueing while paused.
      if (!STATE) return;

      if ((STATE.av_mode || "").toLowerCase() === "spotify") {
        showToast("Spotify Mode — requests disabled", "warn");
        return;
      }
      if (STATE.locked) {
        showToast("Requests locked", "warn");
        return;
      }

      try {
        const r = await fetch("/api/request_video", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ catalog_id: catalogId })
        });
        const j = await r.json().catch(() => ({}));
        if (!r.ok || !j.ok) {
          showToast(j.error || "Request failed", "danger");
          return;
        }
        showToast("Added to queue");
        pollQueue();
      } catch (e) {
        showToast("Request failed (network)", "danger");
      }
    }

    function updateBanners() {
      if (!STATE) return;
      el("spotify_banner").style.display = ((STATE.av_mode || "").toLowerCase() === "spotify") ? "block" : "none";
    }

    function updateTopPills() {
      const av = (STATE?.av_mode || AV_MODE || "partybox").toLowerCase();
      const paused = !!(STATE && STATE.paused);

      const md = el("mode_dot");
      md.classList.remove("ok", "warn", "bad");
      if (av === "spotify") {
        md.classList.add("ok");
        el("mode_text").textContent = "Mode: Spotify";
      } else if (paused) {
        md.classList.add("warn");
        el("mode_text").textContent = "Mode: PartyBox • Paused";
      } else {
        md.classList.add("ok");
        el("mode_text").textContent = "Mode: PartyBox";
      }

      const locked = !!(STATE && STATE.locked);
      const lockPill = el("lock_pill");
      lockPill.style.display = locked ? "" : "none";
      el("lock_dot").classList.remove("ok", "warn", "bad");
      el("lock_dot").classList.add("bad");
      el("lock_text").textContent = "Requests Locked";
    }

    function updateNowPanel() {
      if (!STATE) return;

      const av = (STATE.av_mode || AV_MODE || "partybox").toLowerCase();
      const now = STATE.now;

      if (av === "spotify") {
        el("queue_hint").textContent = "Queued for when PartyBox mode resumes";

        if (now && now.title) {
          el("now_title").textContent = now.title;
        } else {
          el("now_title").textContent = "Spotify is active";
        }

        el("now_note").style.display = "block";
        el("now_note").textContent = "Video playback is paused while Spotify is active.";
        return;
      }

      el("queue_hint").textContent = "What will play after “Now Playing”";

      if (!now) {
        el("now_title").textContent = "—";
        el("now_note").style.display = "none";
        return;
      }

      el("now_title").textContent = now.title || "(untitled)";
      if (now.note_text) {
        el("now_note").style.display = "block";
        el("now_note").textContent = now.note_text;
      } else {
        el("now_note").style.display = "none";
      }

    }

    function isSameAsNowPlaying(q) {
      if (!STATE || !STATE.now || !q) return false;
      const now = STATE.now;

      const ids = [
        ["id", "id"],
        ["catalog_id", "catalog_id"],
        ["youtube_id", "youtube_id"],
      ];
      for (const [qk, nk] of ids) {
        if (q[qk] != null && now[nk] != null && String(q[qk]) === String(now[nk])) return true;
      }

      const qt = String(q.title || "").trim().toLowerCase();
      const nt = String(now.title || "").trim().toLowerCase();
      return !!(qt && nt && qt === nt);
    }

    function renderUpNext(items) {
      const list = el("up_next_list");
      const more = el("up_next_more");
      const empty = el("up_next_empty");
      const toggle = el("btn_upnext_toggle");
      list.innerHTML = "";

      const clean = (items || []).filter((q) => {
        if (String(q.status || "").toLowerCase() === "playing") return false;
        if (isSameAsNowPlaying(q)) return false;
        return true;
      });

      if (!clean.length) {
        empty.style.display = "block";
        list.style.display = "none";
        more.style.display = "none";
        toggle.style.display = "none";
        return;
      }

      empty.style.display = "none";
      list.style.display = "flex";

      const shown = UP_NEXT_EXPANDED ? clean : clean.slice(0, UP_NEXT_LIMIT);
      shown.forEach((q, idx) => {
        const row = document.createElement("div");
        row.className = "listrow";

        const left = document.createElement("div");
        left.className = "grow";

        const t = document.createElement("div");
        t.className = "title ellip";
        t.textContent = `${idx + 1}. ${q.title || "(untitled)"}`;

        left.appendChild(t);

        if (q.note_text) {
          const meta = document.createElement("div");
          meta.className = "sub ellip";
          meta.textContent = q.note_text;
          left.appendChild(meta);
        }

        row.appendChild(left);
        list.appendChild(row);
      });

      if (clean.length > UP_NEXT_LIMIT) {
        toggle.style.display = "inline-flex";
        if (!UP_NEXT_EXPANDED) {
          more.textContent = `Showing ${UP_NEXT_LIMIT} of ${clean.length}`;
          more.style.display = "block";
        } else {
          more.style.display = "none";
        }
      } else {
        toggle.style.display = "none";
        more.style.display = "none";
      }
    }

    function renderQueue(items) {
      const list = el("queue_list");
      list.innerHTML = "";

      const clean = (items || []).filter((q) => {
        if (String(q.status || "").toLowerCase() === "playing") return false;
        if (isSameAsNowPlaying(q)) return false;
        return true;
      });

      if (!clean.length) {
        el("queue_empty").style.display = "block";
        return;
      }
      el("queue_empty").style.display = "none";

      clean.forEach((q, idx) => {
        const row = document.createElement("div");
        row.className = "listrow";

        const left = document.createElement("div");
        left.className = "grow";

        const t = document.createElement("div");
        t.className = "title ellip";
        t.textContent = `${idx + 1}. ${q.title || "(untitled)"}`;

        left.appendChild(t);

        if (q.note_text) {
          const meta = document.createElement("div");
          meta.className = "sub ellip";
          meta.textContent = q.note_text;
          left.appendChild(meta);
        }

        row.appendChild(left);
        list.appendChild(row);
      });
    }

    async function pollState() {
      try {
        const r = await fetch("/api/state", { cache: "no-store" });
        const j = await r.json();
        STATE = j;

        updateBanners();
        updateTopPills();

        // Re-render results to apply disabled state when locked/spotify changes
        renderResults(filterCatalog());
        updateNowPanel();
      } catch (e) {
        // keep UI; don’t spam
      }
    }

    async function pollQueue() {
      try {
        const r = await fetch("/api/queue", { cache: "no-store" });
        const j = await r.json();
        renderUpNext(j.items || []);
        renderQueue(j.items || []);
      } catch (e) {}
    }

    function wireUI() {
      el("btn_search").addEventListener("click", () => renderResults(filterCatalog()));
      el("btn_clear").addEventListener("click", () => { el("q").value = ""; renderResults(filterCatalog()); });
      el("q").addEventListener("input", () => renderResults(filterCatalog()));
      el("btn_refresh").addEventListener("click", () => { pollState(); pollQueue(); });
      el("btn_upnext_toggle").addEventListener("click", () => {
        UP_NEXT_EXPANDED = !UP_NEXT_EXPANDED;
        el("btn_upnext_toggle").textContent = UP_NEXT_EXPANDED ? "Show less" : "Show all";
        pollQueue();
      });
    }

    // init
    wireUI();
    renderResults(filterCatalog());
    pollState();
    pollQueue();

    setInterval(pollState, 1000);
    setInterval(pollQueue, 2000);
  </script>
</body>
</html>
